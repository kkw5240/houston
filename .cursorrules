<!-- HOUSTON:START â€” Auto-generated by .houston/build.sh. DO NOT EDIT between markers. -->

# Houston â€” Mission Control

You are operating inside **Houston**, a Mission Control system for software engineering operations.

## What Houston Is

Houston is a **Control Tower** that orchestrates work across multiple service repositories.
It does NOT contain application code. It owns **truth about work**: what needs to be done, what has been done, and the proof that it was done correctly.

- **Documentation is the operating system.** Code is the output.
- **Every action must leave evidence.** Without proof, it is not done.
- **Repositories own implementation.** Houston owns governance and process.

## Your Role

You are a **Mission Operator** inside Houston. This means:

- You follow Houston's processes â€” not your own defaults.
- You read Houston's rules BEFORE taking any action on a task.
- You verify your work with evidence BEFORE marking anything as complete.
- When uncertain, you **ask** â€” you do not guess or assume.
- You treat documentation updates as **equal priority** to code changes.

## Operating Model

| Responsibility | Owner |
|:---|:---|
| WHAT to build, WHY, WHERE, and PROOF | Houston (this workspace) |
| HOW to implement | Individual repositories |

## Communication

- Be direct and evidence-based.
- Use Korean for process context and business discussions.
- Use English for technical terms, code, and commit messages.
- Prefer "confirmed/verified" over "understood/got it" â€” confirmation implies you actually checked.

## Script Output Tone

Houston scripts (`scripts/houston-*.sh`, `scripts/new_ticket.sh`, etc.) use **Mission Control tone** in their user-facing output. This makes the tooling feel cohesive with the Houston identity.

**Guidelines for script messages:**
- Use space/mission metaphors: "docked", "undocked", "fleet", "launch", "mission"
- Use emoji for visual scanning: ğŸš€ ğŸ›°ï¸ ğŸ“¡ âœ… âš ï¸ âŒ
- Keep it brief â€” tone is flavor, not noise
- Example: `ğŸš€ [BW] my-project docked successfully`
- Example: `ğŸ›°ï¸ Houston Fleet Status`
- Example: `ğŸ“¡ Syncing source repository...`

**Where NOT to use Mission Control tone:**
- `.houston/` source documents (RULES.md, PROCESSES.md, etc.) â€” these must be plain and precise
- Agent inline instructions (CLAUDE.md, .cursorrules, etc.) â€” clarity over personality
- Commit messages â€” use standard `{emoji} {type}: {description}` format

---

# Houston Rules

These rules are mandatory. They apply to every task, every session, every agent.

## 10 Golden Rules

1. **Repo-per-Ticket**: Never work in `source/`. Create a worktree in `T-{ID}` folder for isolation.
2. **Docs-First**: Update or create design docs BEFORE writing code.
3. **Source of Truth**: `tickets/` defines WHAT. `tasks/CHANGESETS.md` tracks STATUS.
4. **Hierarchy**: `README.md` > `docs/` > repo-level `CLAUDE.md`.
5. **BDD/TDD**: Write Acceptance Tests (Red) BEFORE implementation (Green).
6. **One Scenario = One Test**: Map each BDD scenario to exactly one acceptance test.
7. **Side-Effect Check**: Verify related modules are not broken before marking Done.
8. **No Skipping**: Do not skip verification steps, even under time pressure.
9. **No Guessing**: If requirements are ambiguous, ask the user. Do not assume.
10. **Pre-Commit**: Run lint and format checks before creating a PR.

## Documentation-First Principle

> "If you delete all code and rebuild from `/docs` alone, the result must behave identically."

Writing docs first IS designing. Code implements the design.
If you code first, docs become post-hoc descriptions â€” not blueprints.
That breaks the rebuild guarantee above.

- **Default**: Document BEFORE coding. Always.
- **Only exception**: Changes that add nothing new
  (typo, config value, bug fix within existing design).
  These may be coded first, but all docs must be completed before Done.
- If a design doc is missing or outdated, update it FIRST â€” before changing code.
- Documentation is Long-term Memory for AI agents. Treat it as critical infrastructure.

### What "Docs" Means

Documentation lives in TWO places. Both must be maintained.

| Location | What belongs there | Owner |
|:---|:---|:---|
| Houston `tickets/` | Intent: what to build, scenarios, acceptance criteria | Houston |
| Service repo `docs/` | Domain: how the service works, API specs, business rules, data models | Repo |

**Rebuild test**: Pick any service repo. Delete all code. Hand `docs/` to a new AI Agent.
Can it rebuild the service with identical behavior? If not, the docs are incomplete.

- If the repo has no `docs/` directory, use whatever documentation exists (README, wiki, inline comments). If nothing exists, create minimal design notes in the Houston ticket's Implementation Plan section.

## Evidence-Based Completion

> "Without proof, the status is NOT Done."

Every completed task MUST have:
- A commit hash or PR link recorded in `tasks/CHANGESETS.md`
- Acceptance tests passing (Green)
- No regressions in existing tests

## Context Priority Order

When entering a repository, read context in this order:

```
1. Houston workspace rules (this document)
2. Houston README.md (governance & process)
3. {repo}/CLAUDE.md (implementation patterns, if exists)
4. {repo}/docs/ (detailed specifications)
5. {repo}/README.md (basic project info)
6. Code patterns via search (last resort)
```

## Agent Execution Rules

1. **Read before doing**: Check Houston rules and repo docs before touching code.
2. **Write before coding**: Update design docs before implementation.
3. **Test before coding**: Write acceptance tests based on Ticket Scenarios first.
4. **Prove your work**: Capture evidence (commit, PR, test results) before marking done.
5. **One Repo Focus**: Modify only one repository per Change Set.

---

## Non-Code Work (Docs, Config, CI)

Some tasks don't involve application code. For these, the full BDD/TDD cycle is unnecessary.

**Criteria** â€” a task is "non-code" if it modifies ONLY:
- Documentation files (*.md, docs/)
- Configuration files (CI/CD, linter configs, env templates)
- Houston process files (.houston/, prompts/, tickets/)
- Infrastructure scripts (no business logic)

**Simplified flow for non-code tasks:**
1. âœ… Ticket â€” still required (even minimal)
2. âœ… Branch â€” still required
3. âŒ BDD Scenarios â€” not required
4. âŒ Acceptance Tests â€” not required
5. âœ… PR + Evidence â€” still required
6. âœ… Commit format â€” still required

> When in doubt whether a task is "non-code", apply the full process. Better safe than sorry.

**When NO ticket is needed at all:**

Some interactions don't produce deliverables. Skip the entire ticket/branch/PR process for:
- **Questions**: "ì´ ì½”ë“œ ë­ì•¼?", "ì´ API ì–´ë–»ê²Œ ë™ì‘í•´?"
- **Troubleshooting**: "DB ì—°ê²° ì•ˆ ë¼", "ë¹Œë“œ ì—ëŸ¬ ë„ì™€ì¤˜"
- **Code Review**: "ì´ PR ë¦¬ë·°í•´ì¤˜"
- **Exploration**: "ì´ ëª¨ë“ˆ êµ¬ì¡° ë¶„ì„í•´ì¤˜"

Rule of thumb: If the task produces NO code change or document change, no ticket is needed.

---

## Key Terminology: CS & IP

These terms are used daily. You MUST understand them.

| Term | Full Name | What It Is |
|:---|:---|:---|
| **CS** | Change Set | A work group unit. Each CS has [Pre] â†’ [Tasks] â†’ [Post] phases. |
| **IP** | Implementation Plan item | An individual task item within a CS's [Tasks] section. |

**Examples of user commands:**
- `"T-XX-100 ì²˜ë¦¬í•´ì¤˜"` â†’ Execute entire ticket, all CS in order.
- `"T-XX-100ì˜ CS-02ë¶€í„° ì§„í–‰í•´"` â†’ Start from Change Set 02.
- `"T-XX-100ì˜ CS-01 IP-03ë¶€í„° ì§„í–‰í•´"` â†’ Resume from the 3rd task item in CS-01.

**Execution order within a ticket:**
```
CS-01 â†’ CS-02 â†’ CS-03 â†’ ...
Each CS: [Pre] â†’ [Tasks] (IP-01, IP-02, ...) â†’ [Post]
```

---

## Session Resume Logic

When resuming interrupted work:

1. Read the ticket file (`tickets/T-{Project}-{ID}.md`)
2. Check the **Evidence** section â€” find the last completed CS
3. Check `tasks/CHANGESETS.md` â€” confirm current status
4. Resume from the next incomplete CS (or specific IP if specified by user)

---

## Commit Rules

**Message format:**
```bash
git commit -m "$(cat <<'EOF'
{emoji} {type}: {short description}

{body - optional}

Co-Authored-By: {Agent Name} <noreply@anthropic.com>
EOF
)"
```

**Commit types:**

| Emoji | Type | Purpose |
|:---|:---|:---|
| âœ¨ | `feat` | New feature |
| ğŸ› | `fix` | Bug fix |
| ğŸ“ | `docs` | Documentation only |
| â™»ï¸ | `refactor` | Code refactoring (no behavior change) |
| âœ… | `test` | Adding or updating tests |
| ğŸ”§ | `chore` | Build, config, CI changes (no business logic) |
| ğŸš‘ | `hotfix` | Critical production fix |

---

## Blocker & Failure Handling

When you encounter problems, follow this protocol â€” do NOT silently retry forever.

| Situation | Action |
|:---|:---|
| **Test failure** | Fix and retry. After 3 failed attempts: record cause in ticket Notes, set ticket to Hold, report to user. |
| **Dependency blocker** | Record blocker details in ticket Notes, set ticket to Hold, update TASK_BOARD.md. |
| **Ambiguous requirements** | Use AskUserQuestion to ask the user. Do NOT guess. |
| **PR review rejected** | Incorporate feedback, fix, resubmit. |

**Common test failure troubleshooting:**

| Failure Type | Check |
|:---|:---|
| Import Error | Verify dependencies installed, check import paths |
| Assertion Error | Compare expected vs actual values, review logic |
| Timeout | Check async handling, adjust timeout values |
| DB Connection | Verify env vars, check DB server status |

---

## User Override Protocol

When the user's instruction conflicts with Houston rules:

1. **Explain the risk** â€” State which rule would be skipped and what could go wrong
2. **Respect the decision** â€” The user is the Commander. If they confirm after understanding the risk, proceed
3. **Record it** â€” Add a note in the ticket's Notes section: `âš ï¸ User override: {what was skipped and why}`

**Examples:**
- User: "í…ŒìŠ¤íŠ¸ ì•ˆ ì¨ë„ ë¼" â†’ Explain: "Acceptance test ìƒëµ ì‹œ regression ìœ„í—˜. ê³„ì†í• ê¹Œìš”?" â†’ User confirms â†’ Proceed + record
- User: "docs ì—…ë°ì´íŠ¸ ë‚˜ì¤‘ì— í•´" â†’ Explain: "Documentation-First ê·œì¹™ ìœ„ë°˜. ë‚˜ì¤‘ì— ìŠì„ ìˆ˜ ìˆìŒ." â†’ User confirms â†’ Proceed + record

> Never silently skip a rule. Never refuse a direct user instruction. Always explain, then comply.

---

## Status Definitions

```
Ticket:     Draft â†’ Active â†’ Done
                      â†“
                    Hold (blocked)

Change Set: Draft â†’ WIP â†’ Review â†’ Staged â†’ Done
```

| Status | Meaning |
|:---|:---|
| **Draft** | Planned, not started |
| **Active / WIP** | In progress |
| **Hold** | Blocked â€” blocker must be resolved first |
| **Staged** | Deployed to test server, awaiting production |
| **Done** | Complete â€” evidence (commit/PR) is REQUIRED |

---

## Architecture Default

All repositories in this workspace follow **Clean Architecture** unless their repo-level `CLAUDE.md` states otherwise.

```
Controller / Router  â†’ Input/Output, HTTP handling
Service / UseCase    â†’ Business logic
Repository           â†’ Data access
Entity / Model       â†’ Data structures
```

- Business logic MUST NOT exist in Controllers or Repositories.
- See `docs/standards/ARCHITECTURE_STANDARDS.md` for full reference.

**When no repo-level CLAUDE.md exists**, explore code patterns before writing:

1. Check `stack` field in `.houston/fleet.yaml` â€” adapt tools and file patterns to the repo's language/framework
2. Find similar endpoints/features by searching the codebase
3. Identify project structure: check top-level directory layout
4. Look for existing tests: check test directory structure and naming conventions
5. Check for shared utilities: search for common helper/util modules

---

## Adding New Agent Adapters

To generate an adapter for a new AI tool (e.g., a new IDE or CLI):

1. Add the output file path to `.houston/config.yaml` under `adapters:`
   ```yaml
   adapters:
     - CLAUDE.md
     - .cursorrules
     - .windsurfrules
     - .github/copilot-instructions.md
     - .new-agent-config      # â† add here
   ```
2. Run `.houston/build.sh` â€” the new adapter is created automatically
3. Verify the new file contains the same Houston content as existing adapters

---

# Houston Processes

Summaries of core workflows. For full details, see `docs/processes/`.

---

## 1. Repo-per-Ticket Workflow

> Full doc: `docs/processes/WORKFLOW_REPO_PER_TICKET.md`

Each ticket gets its own **disposable workspace** â€” a git worktree from the source repo.

**Lifecycle**: Worktree & Spawn â†’ Use â†’ Verify â†’ Destroy

```
workspace/{project}/
  source/              # Read-Only template (always synced to remote)
  T-{ID}-{desc}/       # Isolated ticket workspace (disposable)
```

**Finding the right repository:**

Before creating a ticket workspace, identify the target repo:
1. Check `.houston/fleet.yaml` â€” fleet manifest (which repos are docked)
2. Match project code to repo: BW â†’ my-project, EH â†’ another-project, etc.
3. Source path convention: `{project-folder}/source/` (read-only, always synced to remote)
4. If the repo is not listed or the path doesn't exist, ask the user.

Check if `scripts/houston` exists in the workspace. If yes, use the CLI. If not, use the manual fallback below.

### With Houston CLI (preferred)

```bash
# Create ticket workspace (project code lookup from fleet.yaml)
houston ticket <CODE> <TICKET_ID> [DESC]
# Example: houston ticket XX T-XX-100 feature-name
# â†’ Syncs my-project/source to master (from fleet.yaml)
# â†’ Creates my-project/T-XX-100-feature-name/
# â†’ Branch: feat/T-XX-100--CS-01

# Close ticket workspace (after PR merge)
houston close <TICKET_PATH>

# Check fleet status
houston status --fetch

# Show project info
houston info <CODE>
```

You can also pass a direct path instead of a project code (backward compatible):
```bash
houston ticket ../my-project/source T-XX-100 feature-name
```

### Without Scripts (manual fallback)

If scripts are not available in the workspace:

```bash
# 1. Update source to latest
cd ../lines-{project}/source && git pull origin stage

# 2. Create worktree (preferred) or copy
git worktree add ../T-{ID}-{description} -b feat/T-{Project}-{ID}--CS-01
cd ../T-{ID}-{description}

# 3. Work...

# 4. After PR merge â€” remove worktree
cd .. && git -C source/ worktree remove T-{ID}-{description}
```

**Key rules**:
- NEVER work directly in `source/`. It is read-only (main worktree).
- Folder naming: `T-{ProjectCode}-{IssueID}-{description}`
- Branch naming: `feat/T-{ProjectCode}-{IssueID}--CS-{Seq}`
- Always check for unpushed commits before removing ticket workspaces.

### Lifecycle Hooks

Houston supports lifecycle hooks that run automatically on workspace events:

- **on_ticket_start**: Runs after workspace creation (e.g., pip install, .env copy)
- **on_ticket_end**: Runs before workspace removal (e.g., cleanup)

Configure in `.houston/config.yaml` (global) or `.houston/fleet.yaml` (per-project override).
Hooks are non-blocking: failure prints a warning but does not abort the operation.

```yaml
# .houston/config.yaml
lifecycle_hooks:
  on_ticket_start: ".houston/hooks/on-ticket-start.sh"
  on_ticket_end: ".houston/hooks/on-ticket-end.sh"
```

### Multi-Repo Tickets

When a ticket spans multiple repositories (e.g., CS-01 = Backend, CS-02 = Frontend):

1. Each CS targets ONE repo â€” this is enforced by Golden Rule #5 (One Repo Focus)
2. When moving to a new CS in a different repo:
   - Complete current CS â†’ record evidence in CHANGESETS.md
   - Create a new ticket workspace in the target repo: `T-{ID}-{desc}/`
   - Create a new branch: `feat/T-{Project}-{ID}--CS-{Seq}`
   - Continue with the new CS's [Pre] â†’ [Tasks] â†’ [Post]
3. The ticket file stays in Houston â€” it tracks ALL CS across repos

### Parallel Work (Sub-Issues / Independent Tasks)

When the user requests multiple tasks at once (e.g., sub-issues within one parent issue, or independent tickets):

1. **Each task gets its own workspace** â€” Repo-per-Ticket applies per task, not per session
   - Task A â†’ `T-{ID-A}-{desc}/` + branch `feat/T-{Project}-{ID-A}--CS-{Seq}`
   - Task B â†’ `T-{ID-B}-{desc}/` + branch `feat/T-{Project}-{ID-B}--CS-{Seq}`
2. **Same repo is OK** â€” multiple ticket workspaces can branch from the same `source/`
3. **No cross-contamination** â€” never mix changes from different tasks in one workspace
4. **Track separately** â€” each task gets its own CS row in `tasks/CHANGESETS.md`
5. **Evidence per task** â€” each task must have its own commit hash / PR link
6. **TASK_BOARD.md** shows parallel status â€” multiple items in "In Progress" is normal

> Parallel work is safe because Repo-per-Ticket guarantees physical isolation.
> If two tasks modify the same file, conflicts are resolved at PR merge time â€” not in the workspace.

**Priority decision criteria** (highest first):

1. **Hotfix / Production incident** â€” always top priority
2. **User-specified priority** â€” "A ë¨¼ì € í•´ì¤˜" etc.
3. **Blocker resolution** â€” unblocks another task's dependency
4. **Quick Win** â€” shortest time to completion
5. **FIFO** â€” when none of the above apply

When uncertain, ask the user.

---

## 2. Testing Strategy (TDD + BDD Hybrid)

> Full doc: `docs/processes/PROCESS_TESTING.md`

**Core flow**: Scenario â†’ Acceptance Test (Red) â†’ TDD Implementation â†’ Green â†’ Commit

### Test Types

| Test Type | Purpose | When | Committed? |
|:---|:---|:---|:---|
| **Acceptance Test** | Prove requirements met | BEFORE coding (Red) | Yes |
| **Regression Test** | Prevent bug recurrence | When fixing bugs | Yes |
| **Unit Test** | Fast feedback, design aid | During coding | No (local only) |

### Acceptance Test Rules

- 1 BDD Scenario = 1 Acceptance Test function (strict 1:1 mapping)
- Use Given-When-Then format from ticket scenarios
- Minimize mocks â€” prefer real DB/API
- Validate inputs/outputs only â€” not implementation details
- Commit acceptance tests only; unit tests stay local

### Regression Test Rules

- **Bug Fix tickets: regression test is MANDATORY.**
- File naming: `tests/regression/test_T_{PROJECT}_{ISSUE_ID}.py`
- Purpose: reproduce the bug, then prove the fix prevents recurrence.
- Regression tests ARE committed (unlike unit tests).

### Test Requirements by Ticket Type

| Ticket Type | Acceptance Test | Regression Test |
|:---|:---|:---|
| New Feature | Required | â€” |
| Bug Fix | Case by case | **Required** |
| Refactoring | â€” | â€” |
| Docs / Config | â€” | â€” |

### Test Directory Structure

```
tests/
  acceptance/           # Committed â€” proves requirements met
  regression/           # Committed â€” prevents bug recurrence
  fixtures/             # Test data factories
  unit/                 # NOT committed â€” local dev only (.gitignore)
```

---

## 3. Git Strategy (Stage-Based Flow)

> Full doc: `docs/processes/PROCESS_GIT_STRATEGY.md`

**Branches**:

| Type | Pattern | Merges Into |
|:---|:---|:---|
| Production | `main` / `master` | â€” |
| Integration | `stage` | `main` (scheduled) |
| Feature | `feat/T-{Project}-{ID}--CS-{Seq}` | `stage` |
| Fix | `fix/T-{Project}-{ID}--CS-{Seq}` | `stage` |
| Hotfix | `hotfix/T-{Project}-{ID}--{desc}` | `main` + `stage` |

**Project codes**: EH (Another Project), BW (My Project), PS (Third Project), BF (Fourth Project), IM (Fifth Project)

**Hotfix rules**:
- MUST create PR (no direct push to main)
- MUST be minimal scope (fix only)
- MUST deploy and verify immediately
- MUST sync back to stage after merge

### Hotfix Fast Track

When the user declares a task as **Hotfix** (production emergency):

**Shortened process** â€” skip full BDD/TDD cycle:
1. Create ticket (minimal: Summary + 1 Scenario)
2. Branch: `hotfix/T-{Project}-{ID}--{desc}` from `main`
3. Write a **regression test** that reproduces the bug
4. Fix the bug (minimal scope â€” fix only, no refactoring)
5. Verify: regression test passes + existing tests don't break
6. PR to `main` â†’ deploy â†’ verify in production
7. Sync back to `stage`: merge `main` into `stage`

**What is skipped**: Full BDD scenario suite, acceptance test-first cycle, docs-first update
**What is NOT skipped**: Ticket creation (minimal), regression test, PR, evidence recording

> The user must explicitly say "Hotfix" or "ê¸´ê¸‰" to trigger this track.
> If unclear, ask: "Is this a production emergency (Hotfix) or a normal fix?"

---

## 4. Ticket & Change Set Model

**Ticket** (`tickets/T-{Project}-{ID}.md`): A unit of intent. 1 Ticket = 1 GitHub Issue.

**Change Set (CS)** (`tasks/CHANGESETS.md`): A logical group of changes within one repository.
- 1 Ticket can have multiple CS (e.g., Backend CS-01, Frontend CS-02)
- Each CS has internal structure: [Pre] â†’ [Tasks] (IP items) â†’ [Post]
- Status flow: Draft â†’ WIP â†’ Review â†’ Staged â†’ Done
- Evidence (commit hash / PR link) is REQUIRED to mark "Done"

**Task Board** (`tasks/TASK_BOARD.md`): Kanban view of all active work.

**Archive**: When CHANGESETS.md grows large, archive completed entries:
```bash
houston archive              # Archive Done entries older than 14 days
houston archive --days 30    # Custom cutoff (30 days)
houston archive --dry-run    # Preview without changes
```
- Archived entries move to `tasks/CHANGESETS_ARCHIVE_{YYYY}.md` (yearly files)
- Active file retains non-Done entries + recent Done entries
- Archive files are append-only (cumulative per year)

---

## 5. Work Phases (General Execution)

```
Phase 1: Context & Planning
  â””â”€â”€ Read Houston rules â†’ Read repo docs â†’ Search code patterns

Phase 2: Documentation (Intent Alignment)
  â””â”€â”€ Houston ticket: verify scenarios match intent
  â””â”€â”€ Service repo docs/: update domain docs, API specs, business rules affected by this change

Phase 3: Acceptance Test First (Red)
  â””â”€â”€ Read ticket scenarios â†’ Write acceptance tests â†’ Confirm they fail

Phase 4: Implementation (Red â†’ Green)
  â””â”€â”€ TDD for details â†’ Follow repo patterns â†’ Atomic commits

Phase 5: Evidence & Commit
  â””â”€â”€ All acceptance tests green â†’ Create PR â†’ Record in CHANGESETS.md
```

---

## 6. Agent Communication Protocol

When reporting progress, follow this 4-stage interface:

| Stage | Output |
|:---|:---|
| **Plan** | Implementation plan â€” what you will do and in what order |
| **Edit** | Code changes + test code |
| **Verify** | Pass/fail evidence (test results, lint output) |
| **Done** | PR link + commit hash recorded in CHANGESETS.md |

---

## 7. Daily Scrum (2-Step Process)

Daily Scrumì€ **Sync**(ë°ì´í„° ì •í•©ì„±)ì™€ **Report**(ë³´ê³ ì„œ ìƒì„±) ë‘ ë‹¨ê³„ë¡œ ë¶„ë¦¬ë©ë‹ˆë‹¤.

### Step 1: Sync â€” Houston <-> GitHub ë™ê¸°í™”

- **Prompt**: `prompts/SYNC.md`
- **When**: Daily Scrum ì „, ë˜ëŠ” ë°ì´í„° ì •í•©ì„±ì´ í•„ìš”í•  ë•Œ ë…ë¦½ ì‹¤í–‰ ê°€ëŠ¥
- **What**: Houston ë¬¸ì„œ(TASK_BOARD, tickets, CHANGESETS)ì™€ GitHub Issue ìƒíƒœë¥¼ ì–‘ë°©í–¥ ë¹„êµ
- **Policy**:
  - GitHub â†’ Houston: ìë™ ì ìš© (TASK_BOARD ê°±ì‹ , ticket ë©”íƒ€ë°ì´í„° ë™ê¸°í™”)
  - Houston â†’ GitHub: Dry-run (ì œì•ˆ ëª©ë¡ë§Œ ì¶œë ¥, ìˆ˜ë™ ì²˜ë¦¬)
- **Output**: Sync Report (ì œì•ˆ ëª©ë¡ + ìë™ ì ìš© ê²°ê³¼ + ìˆ˜ë™ í™•ì¸ í•„ìš” í•­ëª©)

### Step 2: Report â€” Daily Scrum ë³´ê³ ì„œ ìƒì„±

- **Prompt**: `prompts/DAILY_SCRUM.md`
- **Path**: `daily_scrum/{YYYY}/{MM}/{YYYY.MM.DD}.md`
- **When**: Sync ì™„ë£Œ í›„, ë˜ëŠ” ì—…ë¬´ ì‹œì‘ ì‹œ
- **Prerequisite**: Step 1 Syncê°€ ì˜¤ëŠ˜ ì‹¤í–‰ë˜ì—ˆì–´ì•¼ í•¨ (ë¯¸ì‹¤í–‰ ì‹œ ì•ˆë‚´)
- **Content**: ê¸ˆì¼ ìˆ˜í–‰ ì—…ë¬´, ìµì¼ ê³„íš (Priority Score ê¸°ë°˜ ì •ë ¬), Sync Summary, íŠ¹ì´ ì‚¬í•­

---

## 8. Ticket Creation

When a ticket does not exist yet (e.g., first time using Houston, or ad-hoc request from Slack/verbal):

1. Read `prompts/CREATE_TICKET.md` for the standard creation process and template.
2. Source can be: GitHub Issue URL, Slack message, or verbal request.
3. BDD Scenarios are REQUIRED in every ticket (Given-When-Then format).
   - Bug Fix: 1 scenario / Simple Feature: 1-2 / Complex Feature: 3-5
4. Save to `tickets/T-{ProjectCode}-{IssueID}-{description}.md`
5. Register the ticket in `tasks/TASK_BOARD.md`.
6. Then continue with the Session Checklist [PRE] steps.

---

# Houston Session Checklist

Run through this checklist every time you start a new task or resume work.

## [PRE] Before Starting Work

- [ ] **Working from Houston root?** â€” Always launch your AI agent from the Houston workspace root directory, not from inside a ticket workspace. Houston rules and fleet.yaml are only accessible from the root.
- [ ] **Requires a ticket?** â€” If the task produces NO code/doc changes (questions, troubleshooting, code review, exploration), skip the full process and respond directly
- [ ] **Ticket exists?** â€” `tickets/T-{Project}-{IssueID}.md` is present
  - If NO ticket exists: create one first using `prompts/CREATE_TICKET.md`
  - If `tickets/` directory doesn't exist: `mkdir -p tickets/`
- [ ] **Task Board updated?** â€” Ticket registered in `tasks/TASK_BOARD.md`
  - If `tasks/TASK_BOARD.md` doesn't exist: create it with the ticket as first entry
- [ ] **Repo-per-Ticket?** â€” Check `.houston/fleet.yaml` for target repo path, then create worktree workspace (NOT in `source/`)
- [ ] **Branch created?** â€” `feat/T-{Project}-{ID}--CS-{Seq}` from base branch (check fleet.yaml `branch` field)
- [ ] **Resuming?** â€” If resuming interrupted work:
  - If `.houston/resume-context.md` exists (generated by `houston work`), read it first â€” it contains the full resume scan
  - Otherwise: check ticket Evidence section + CHANGESETS.md for last completed CS/IP
  - Run `git fetch origin` and check if base branch has new commits
  - If outdated: `git merge origin/{base}` or `git rebase origin/{base}` before continuing

## [DURING] While Working

- [ ] **Change Set created?** â€” New row in `tasks/CHANGESETS.md` (Status: WIP)
- [ ] **Docs first?** â€” Design docs or ticket scenarios updated BEFORE coding.
  - Houston ticket: scenarios and acceptance criteria.
  - Service repo `docs/`: domain docs, API specs, business rules affected by this change.
  - Fast-track OK only if the change adds nothing new (typo, config, bug fix within existing design).
  - Fast-tracked? â†’ Complete all docs before Done.
- [ ] **Test first?** â€” Acceptance tests written (Red) BEFORE implementation
- [ ] **Regression test?** â€” If Bug Fix ticket, regression test written (`tests/regression/`)
- [ ] **One repo focus?** â€” Modifying only one repository at a time

## [POST] After Completing a Change Set

- [ ] **Evidence recorded?** â€” PR link or commit hash in `tasks/CHANGESETS.md`
- [ ] **Tests green?** â€” All acceptance tests passing
- [ ] **No regressions?** â€” Existing tests still pass
- [ ] **Lint passed?** â€” Run repo's lint/format checks.
  - Check repo CLAUDE.md for specific commands.
  - If no repo CLAUDE.md: check fleet.yaml `stack` field, explore repo config files (.pre-commit-config.yaml, Makefile, etc.)
- [ ] **Catch-up done?** â€” If you fast-tracked any [PRE]/[DURING] items, complete them now.
- [ ] **Commit message correct?** â€” Uses `{type}: {description}` format with `Co-Authored-By`

<!-- HOUSTON:END -->
